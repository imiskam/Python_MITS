"""
Немного вернемся в тему классов и поговорим
о магическом методе __call__
"""


# создадим обычный класс Counter
class Counter:
    def __init__(self):
        self.__counter = 0


example = Counter()

"""
Ранее мы уже создавали подобные классы и видели пару круглых
скобок после названия самого класса. Тем самым - мы вызывали
класс. Кроме того, ранее и сейчас мы пользуемся функциями, 
в которых круглые скобки обозначают их вызов. 
прим. print(), len() и т.п. в т.ч. пользовательские функции
"""

"""
example = Counter()
в момент создания экземпляра класса по умолчанию
срабатывает метод __call__ 
он выглядит следующим образом:

====== упрощенная реализация ======

__call__(self, *args, **kwargs):
    obj = self.__new__(self, *args, **kwargs) # сначала вызывается метод __new__
    self.__init__(obj, *args, **kwargs) # а после срабатывает инициализатор __init__
    return obj

Благодаря магическому методу __call__ мы можем вызывать классы подобно функциям,
однако, экземпляры классы мы так вызывать не сможем
"""

example1 = Counter()
# example1()
# >> TypeError: 'Counter' object is not callable

"""
Как мы видим, мы получили ошибку TypeError: 'Counter' object is not callable
это означает, что экземпляры классы не являются вызываемыми. Это связано с тем
что магический метод __call__ для экземпляров нашего класса Counter() не определен.
"""


# создадим еще один класс

class Example:
    def __init__(self):
        self.var = 0

    # переопределяем метод __call__
    def __call__(self, *args, **kwargs):
        print('__call__')
        self.var += 1
        print(self.var)
        return self.var


ex2 = Example()
ex3 = Example()
ex2()   # вызываем экземпляр класса
ex3()
