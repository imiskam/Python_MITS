a = 1
"""
функция iter() отработает на любом объекте, у которого есть
метод __iter__ или метод __getitem__.
1. Метод __iter__ возвращает итератор. Если этого метода нет,
функция iter() проверяет, нет ли метода __getitem__.

2. Метод __getitem__ - метод, который позволяет получать
элементы по индексу. Если метод __getitem__ есть, возвращается
итератор, который проходится по элементам, используя индекс, начиная с 0

давайте убедимся в этом. 
Мы знаем, что наши строки поддерживают индексацию, т.е. у объектов
класса str должен содержаться метод __getitem__, а также, так как раньше
мы неоднократно использовали строки для проведения итерации попробуем предположить, что
у строк также содержится метод __iter__. 
"""

example = 'Пример строки'
print('__getitem__' in example.__dir__())  # >>> True
print('__iter__' in example.__dir__())  # >>> True

"""
Со строкам вроде бы все понятно, а вдруг у тех объектов, которые мы раньше
считали неитерабельными и неподдерживающими индексацию все же есть
указанные методы. Первым типом, который приходит на ум - является integer.
Давайте проверим наличие данных методов во всех встроенных типах данных, которые мы уже прошли.
"""

types_list = [
    1,  # integer
    'строка',  # string
    [1, 2, 3],  # list
    {1, 2, 3},  # set
    1.1,  # float
    True,  # bool
    (1, 2, 3),  # tuple
    frozenset({1, 2, 3}),  # frozenset
    {'key': 'value'},  # dict
    range(1, 10)    # range
]

for _ in types_list:
    print(f"Тип данных: {type(_)}, "
          f"наличие __iter__: {'__iter__' in _.__dir__()}, "
          f"наличие __getitem__: {'__getitem__' in _.__dir__()}")

"""
Естественно перед тем, как использовать тот или иной класс, в том числе и пользовательский,
таким простым способом Вы можете убедиться в том, является ли он итерабельным или нет, поддерживающим
индексацию или нет. 
"""
