"""
Для реализации property мы также можем воспользоваться соответствующими декораторами.
Реализовано это с той целью, чтобы не создавать отдельный атрибут для работы со свойствами
"""


class Example:

    def __init__(self, x, y):
        # задаем инициализатор на получение
        # двух свойств x и y
        # указываем, что данные значения будут private
        self.__x = x
        self.__y = y

    # указываем декоратор property
    # указывать его обязательно нужно перед геттером, коим и является метод change
    @property
    def change(self):
        return self.__x

    # в момент, когда мы применяем декоратор property наш геттер становится объектом
    # в property имеется 2 атрибута, это getter и setter
    # getter мы получили с помощью метода change, который возвращал нам старое значение x
    # Теперь, зная, что наше Property имеет 2 данных атрибута, а getter мы уже получили
    # нам нужно задать сеттер
    # указываем декоратор, в котором из атрибута change мы вызываем метод setter
    # над методом, который изменит наше значение x
    # ИМЕНА МЕТОДОВ ДОЛЖНЫ СОВПАДАТЬ!
    @change.setter
    def change(self, new_x):
        self.__x = new_x


"""
При этом следует учитывать, что в случае, если мы укажем только геттер для свойства property
мы не сможем устанавливать значение через него.


Попробуйте сейчас удалить сеттер change. Вы убедитесь, что получить через геттер значение x можно,
а изменить данное значение мы не сможем, т.к. отсутствует сеттер для него. 
"""

examp = Example(10, 25)
examp.change = 55
examp.change_2 = 55
del examp.change_2
print(examp.__dir__())

# объяснение property.Стр. 28 презентации ООП ч. 2
